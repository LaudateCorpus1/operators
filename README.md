The df.operators library
========================

Welcome to the **df.operators** library, the perfect tool to build
highly efficient, move-aware arithmetic data types with C++11.

###Table of content

[Preface](#preface)<br>
[Rationale](#rationale)<br>
[Example](#example)<br>
[Requirements](#requirements)<br>
[Installation](#installation)<br>
[Provided templates](#provided-templates)<br>
[Commutativity](#commutativity)<br>
[noexcept](#noexcept)<br>
[Contact](#contact)<br>
[License](#license)

Preface
-------

The **df.operators** library is the next logical step in the evolution of the
[Boost.Operators](http://www.boost.org/doc/libs/1_53_0/libs/utility/operators.htm) library,
whose maintainer I became in 2002. Since then, C++ has changed significiantly and
with C++11, the time has come for a complete rewrite and to get rid of some
*very* old legacy code and work-arounds.

Rationale
---------

Overloaded operators for class types typically occur in groups.
If you can write `x&nbsp;+&nbsp;y`, you probably also want to be able to write `x&nbsp;+=&nbsp;y`.
If you can write `x&nbsp;<&nbsp;y`, you also want `x&nbsp;>&nbsp;y`, `x&nbsp;>=&nbsp;y`, and `x&nbsp;<=&nbsp;y`.
Moreover, unless your class has really surprising behavior, some of these related operators
can be defined in terms of others (e.g. `x&nbsp;>=&nbsp;y` <=> `!(x&nbsp;<&nbsp;y)`).

Replicating these operators for multiple classes is both tedious and error-prone.
The **df.operators** templates help by generating operators for you based on
other operators you've defined in your class.

The generated operators are overloaded to take full advantage of move-aware types
and are carefully written to allow the compiler to apply important optimizations
to avoid unneccessary temporary objects. All generated operators are automatically
marked `noexcept` when the underlying base operations are themself marked as
`noexcept`.

Example
-------

```c++
#include <df/operators.hpp>

class MyInt
  : df::commutative_addable< MyInt >,
    df::multipliable< MyInt, double >
{
public:
  // create a new instance of MyInt
  MyInt( const int v ) noexcept;

  // copy and move constructor
  MyInt( const MyInt& v ) noexcept;
  MyInt( MyInt&& v ) noexcept; // optional

  // copy and move assignment
  MyInt& operator=( const MyInt& v ) noexcept;
  MyInt& operator=( MyInt&& v ) noexcept; // optional

  // addition of another MyInt
  MyInt& operator+=( const MyInt& v ) noexcept;
  MyInt& operator+=( MyInt&& v ) noexcept; // optional

  // multiplication by a scalar
  MyInt& operator*=( const double v ) noexcept;
};
```

then the **df.operators** templates *generate* the following operators:

```c++
// generated by df::commutative_addable< MyInt >
MyInt   operator+( const MyInt& lhs, const MyInt& rhs ) noexcept;
MyInt&& operator+( const MyInt& lhs, MyInt&&      rhs ) noexcept;
MyInt&& operator+( MyInt&&      lhs, const MyInt& rhs ) noexcept;
MyInt&& operator+( MyInt&&      lhs, MyInt&&      rhs ) noexcept;

// generated by df::multipliable< MyInt, double >
MyInt   operator*( const MyInt& lhs, const double& rhs ) noexcept;
MyInt   operator*( const MyInt& lhs, double&&      rhs ) noexcept;
MyInt&& operator*( MyInt&&      lhs, const double& rhs ) noexcept;
MyInt&& operator*( MyInt&&      lhs, double&&      rhs ) noexcept;
```

>Note: The `//&nbsp;optional` in `class&nbsp;MyInt` above marks methods
>that you typically only add when your class benefits from an
>rvalue reference parameter. If there is no benefit for the
>implementation, you can just omit these methods. If you leave
>them out, **df.operators** will simply call the corresponding
>non-movable version that takes the parameter by const lvalue
>reference.

Requirements
------------

The following compilers and versions are supported and tested:

* GCC 4.7 or newer
* Clang 3.2 or newer

Remember to enable C++11, e.g., provide `--std=c++11` or similar options.

>Note: If you use or test the **df.operators** library with other compilers,
>e.g., Visual C++, Intel C++, or any other compiler, or if you tested older
>versions of Clang, I'd like to hear from you.

>Note: For compilers that don't support `noexcept`, see chapter [noexcept](#noexcept).

Installation
------------

The **df.operators** library is a header-only library. There is nothing to build or install,
just copy it somewhere and add the appropriate compiler option to add its `include` directory
to the compiler's include path, e.g., `-I&nbsp;/path/to/df.operators/include`.

Provided templates
------------------

The following templates are available:

<table>

  <tr>
    <th>Template</th><th>Provides</th><th>Requires</th>
  </tr>

  <!-- equality_comparable -->
  <tr valign="top">
    <td>
      <code>equality_comparable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>bool&nbsp;operator!=(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>static_cast&lt;&nbsp;bool&nbsp;&gt;(&nbsp;t&nbsp;==&nbsp;t1&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>equality_comparable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>bool&nbsp;operator!=(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>bool&nbsp;operator==(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>bool&nbsp;operator!=(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>static_cast&lt;&nbsp;bool&nbsp;&gt;(&nbsp;t&nbsp;==&nbsp;u&nbsp;)</code>
    </td>
  </tr>

  <!-- less_than_comparable -->
  <tr valign="top">
    <td>
      <code>less_than_comparable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>bool&nbsp;operator&gt;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code>
      <code>bool&nbsp;operator&lt;=(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code>
      <code>bool&nbsp;operator&gt;=(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>static_cast&lt;&nbsp;bool&nbsp;&gt;(&nbsp;t&nbsp;&lt;&nbsp;t1&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>less_than_comparable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>bool&nbsp;operator&lt;=(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>bool&nbsp;operator&gt;=(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>bool&nbsp;operator&lt;(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>bool&nbsp;operator&gt;(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>bool&nbsp;operator&lt;=(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>bool&nbsp;operator&gt;=(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>static_cast&lt;&nbsp;bool&nbsp;&gt;(&nbsp;t&nbsp;&lt;&nbsp;u&nbsp;)</code><br>
      <code>static_cast&lt;&nbsp;bool&nbsp;&gt;(&nbsp;t&nbsp;&gt;&nbsp;u&nbsp;)</code>
    </td>
  </tr>

  <!-- equivalent -->
  <tr valign="top">
    <td>
      <code>equivalent&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>bool&nbsp;operator==(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>static_cast&lt;&nbsp;bool&nbsp;&gt;(&nbsp;t&nbsp;&lt;&nbsp;t1&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>equivalent&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>bool&nbsp;operator==(&nbsp;const T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code>
    </td><td>
      <code>static_cast&lt;&nbsp;bool&nbsp;&gt;(&nbsp;t&nbsp;&lt;&nbsp;u&nbsp;)</code><br>
      <code>static_cast&lt; bool&nbsp;&gt;(&nbsp;t&nbsp;&gt;&nbsp;u&nbsp;)</code>
    </td>
  </tr>

  <!-- partially_ordered -->
  <tr valign="top">
    <td>
      <code>partially_ordered&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>bool&nbsp;operator&gt;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>bool&nbsp;operator&lt;=(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>bool&nbsp;operator&gt;=(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>static_cast&lt;&nbsp;bool&nbsp;&gt;(&nbsp;t&nbsp;&lt;&nbsp;t1&nbsp;)</code><br>
      <code>static_cast&lt;&nbsp;bool&nbsp;&gt;(&nbsp;t&nbsp;==&nbsp;t1&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>partially_ordered&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>bool&nbsp;operator&lt;=(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>bool&nbsp;operator&gt;=(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>bool&nbsp;operator&lt;(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>bool&nbsp;operator&gt;(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>bool&nbsp;operator&lt;=(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>bool&nbsp;operator&gt;=(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>static_cast&lt;&nbsp;bool&nbsp;&gt;(&nbsp;t&nbsp;&lt;&nbsp;u&nbsp;)</code><br>
      <code>static_cast&lt;&nbsp;bool&nbsp;&gt;(&nbsp;t&nbsp;&gt;&nbsp;u&nbsp;)</code><br>
      <code>static_cast&lt;&nbsp;bool&nbsp;&gt;(&nbsp;t&nbsp;==&nbsp;u&nbsp;)</code>
    </td>
  </tr>

  <tr>
    <th>Template</th><th>Provides</th><th>Requires</th>
  </tr>

  <!-- addable -->
  <tr valign="top">
    <td>
      <code>commutative_addable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator+(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator+(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator+(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator+(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;+=&nbsp;t</code><br>
      <code>tmp&nbsp;+=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>commutative_addable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator+(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator+(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator+(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator+(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator+(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator+(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator+(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator+(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;+=&nbsp;u</code><br>
      <code>tmp&nbsp;+=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>addable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator+(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&nbsp;operator+(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator+(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator+(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;+=&nbsp;t</code><br>
      <code>tmp&nbsp;+=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>addable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator+(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator+(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator+(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator+(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;+=&nbsp;u</code><br>
      <code>tmp&nbsp;+=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>addable_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator+(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator+(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator+(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator+(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;tmp(&nbsp;std::move(&nbsp;u&nbsp;)&nbsp;)</code><br>
      <code>tmp&nbsp;+=&nbsp;t</code><br>
      <code>tmp&nbsp;+=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr>

  <!-- subtractable -->
  <tr valign="top">
    <td>
      <code>subtractable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator-(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&nbsp;operator-(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator-(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator-(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;-=&nbsp;t</code><br>
      <code>tmp&nbsp;-=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>subtractable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator-(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator-(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator-(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator-(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;-=&nbsp;u</code><br>
      <code>tmp&nbsp;-=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>subtractable_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator-(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator-(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator-(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator-(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;tmp(&nbsp;std::move(&nbsp;u&nbsp;)&nbsp;)</code><br>
      <code>tmp&nbsp;-=&nbsp;t</code><br>
      <code>tmp&nbsp;-=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr>

  <!-- multipliable -->
  <tr valign="top">
    <td>
      <code>commutative_multipliable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator*(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator*(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator*(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator*(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;*=&nbsp;t</code><br>
      <code>tmp&nbsp;*=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>commutative_multipliable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator*(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator*(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator*(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator*(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator*(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator*(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator*(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator*(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;*=&nbsp;u</code><br>
      <code>tmp&nbsp;*=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>multipliable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator*(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&nbsp;operator*(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator*(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator*(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;*=&nbsp;t</code><br>
      <code>tmp&nbsp;*=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>multipliable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator*(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator*(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator*(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator*(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;*=&nbsp;u</code><br>
      <code>tmp&nbsp;*=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>multipliable_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator*(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator*(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator*(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator*(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;tmp(&nbsp;std::move(&nbsp;u&nbsp;)&nbsp;)</code><br>
      <code>tmp&nbsp;*=&nbsp;t</code><br>
      <code>tmp&nbsp;*=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr>

  <!-- dividable -->
  <tr valign="top">
    <td>
      <code>dividable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator/(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&nbsp;operator/(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator/(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator/(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;/=&nbsp;t</code><br>
      <code>tmp&nbsp;/=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>dividable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator/(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator/(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator/(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator/(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;/=&nbsp;u</code><br>
      <code>tmp&nbsp;/=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>dividable_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator/(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator/(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator/(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator/(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;tmp(&nbsp;std::move(&nbsp;u&nbsp;)&nbsp;)</code><br>
      <code>tmp&nbsp;/=&nbsp;t</code><br>
      <code>tmp&nbsp;/=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr>

  <!-- modable -->
  <tr valign="top">
    <td>
      <code>modable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator%(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&nbsp;operator%(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator%(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator%(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;%=&nbsp;t</code><br>
      <code>tmp&nbsp;%=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>modable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator%(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator%(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator%(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator%(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;%=&nbsp;u</code><br>
      <code>tmp&nbsp;%=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>modable_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator%(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator%(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator%(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator%(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;tmp(&nbsp;std::move(&nbsp;u&nbsp;)&nbsp;)</code><br>
      <code>tmp&nbsp;%=&nbsp;t</code><br>
      <code>tmp&nbsp;%=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr>

  <tr>
    <th>Template</th><th>Provides</th><th>Requires</th>
  </tr>

  <!-- andable -->
  <tr valign="top">
    <td>
      <code>commutative_andable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator&amp;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&amp;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&amp;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&amp;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;&amp;=&nbsp;t</code><br>
      <code>tmp&nbsp;&amp;=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>commutative_andable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator&amp;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator&amp;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&amp;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&amp;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator&amp;(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&amp;(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator&amp;(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&amp;(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;&amp;=&nbsp;u</code><br>
      <code>tmp&nbsp;&amp;=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>andable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator&amp;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&nbsp;operator&amp;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&amp;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&amp;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;&amp;=&nbsp;t</code><br>
      <code>tmp&nbsp;&amp;=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>andable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator&amp;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator&amp;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&amp;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&amp;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;&amp;=&nbsp;u</code><br>
      <code>tmp&nbsp;&amp;=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>andable_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator&amp;(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator&amp;(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator&amp;(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator&amp;(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;tmp(&nbsp;std::move(&nbsp;u&nbsp;)&nbsp;)</code><br>
      <code>tmp&nbsp;&amp;=&nbsp;t</code><br>
      <code>tmp&nbsp;&amp;=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr>

  <!-- orable -->
  <tr valign="top">
    <td>
      <code>commutative_orable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator|(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator|(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator|(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator|(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;|=&nbsp;t</code><br>
      <code>tmp&nbsp;|=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>commutative_orable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator|(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator|(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator|(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator|(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator|(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator|(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator|(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator|(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;|=&nbsp;u</code><br>
      <code>tmp&nbsp;|=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>orable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator|(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&nbsp;operator|(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator|(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator|(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;|=&nbsp;t</code><br>
      <code>tmp&nbsp;|=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>orable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator|(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator|(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator|(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator|(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;|=&nbsp;u</code><br>
      <code>tmp&nbsp;|=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>orable_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator|(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator|(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator|(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator|(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;tmp(&nbsp;std::move(&nbsp;u&nbsp;)&nbsp;)</code><br>
      <code>tmp&nbsp;|=&nbsp;t</code><br>
      <code>tmp&nbsp;|=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr>

  <!-- xorable -->
  <tr valign="top">
    <td>
      <code>commutative_xorable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator^(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator^(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator^(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator^(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;^=&nbsp;t</code><br>
      <code>tmp&nbsp;^=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>commutative_xorable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator^(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator^(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator^(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator^(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator^(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator^(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator^(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator^(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;^=&nbsp;u</code><br>
      <code>tmp&nbsp;^=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>xorable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator^(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&nbsp;operator^(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator^(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator^(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;^=&nbsp;t</code><br>
      <code>tmp&nbsp;^=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>xorable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator^(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator^(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator^(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator^(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;^=&nbsp;u</code><br>
      <code>tmp&nbsp;^=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>xorable_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator^(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator^(&nbsp;const&nbsp;U&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator^(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;const&nbsp;T&amp;&nbsp;t&nbsp;)</code><br>
      <code>T&nbsp;operator^(&nbsp;U&amp;&amp;&nbsp;u,&nbsp;T&amp;&amp;&nbsp;t&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;tmp(&nbsp;std::move(&nbsp;u&nbsp;)&nbsp;)</code><br>
      <code>tmp&nbsp;^=&nbsp;t</code><br>
      <code>tmp&nbsp;^=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr>

  <tr>
    <th>Template</th><th>Provides</th><th>Requires</th>
  </tr>

  <!-- left_shiftable -->
  <tr valign="top">
    <td>
      <code>left_shiftable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator&lt;&lt;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&nbsp;operator&lt;&lt;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&lt;&lt;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&lt;&lt;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;&lt;&lt;=&nbsp;t</code><br>
      <code>tmp&nbsp;&lt;&lt;=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>left_shiftable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator&lt;&lt;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator&lt;&lt;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&lt;&lt;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&lt;&lt;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;&lt;&lt;=&nbsp;u</code><br>
      <code>tmp&nbsp;&lt;&lt;=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr>

  <!-- right_shiftable -->
  <tr valign="top">
    <td>
      <code>right_shiftable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator&gt;&gt;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&nbsp;operator&gt;&gt;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&gt;&gt;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;T&amp;&nbsp;t1&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&gt;&gt;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;T&amp;&amp;&nbsp;t1&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;&gt;&gt;=&nbsp;t</code><br>
      <code>tmp&nbsp;&gt;&gt;=&nbsp;std::move(&nbsp;t&nbsp;)</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>right_shiftable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator&gt;&gt;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&nbsp;operator&gt;&gt;(&nbsp;const&nbsp;T&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&gt;&gt;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;const&nbsp;U&amp;&nbsp;u&nbsp;)</code><br>
      <code>T&amp;&amp;&nbsp;operator&gt;&gt;(&nbsp;T&amp;&amp;&nbsp;t,&nbsp;U&amp;&amp;&nbsp;u&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>tmp&nbsp;&gt;&gt;=&nbsp;u</code><br>
      <code>tmp&nbsp;&gt;&gt;=&nbsp;std::move(&nbsp;u&nbsp;)</code>
    </td>
  </tr>

  <tr>
    <th>Template</th><th>Provides</th><th>Requires</th>
  </tr>

  <!-- incrementable -->
  <tr valign="top">
    <td>
      <code>incrementable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator++(&nbsp;T&amp;&nbsp;t,&nbsp;int&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>++t</code>
    </td>
  </tr>

  <!-- decrementable -->
  <tr valign="top">
    <td>
      <code>decrementable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>T&nbsp;operator--(&nbsp;T&amp;&nbsp;t,&nbsp;int&nbsp;)</code>
    </td><td>
      <code>T&nbsp;tmp(&nbsp;t&nbsp;)</code><br>
      <code>--t</code>
    </td>
  </tr>

</table>

The following templates provide common groups of related operations.
For example, since a type which is left shiftable is usually also
right shiftable, the `shiftable` template provides the combined operators
of both.

<table>

  <tr>
    <th>Template</th><th>Provides</th>
  </tr>

  <!-- totally_ordered -->
  <tr valign="top">
    <td>
      <code>totally_ordered&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>equality_comparable&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>less_than_comparable&lt;&nbsp;T&nbsp;&gt;</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>totally_ordered&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>equality_comparable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>less_than_comparable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td>
  </tr>

  <!-- ring -->
  <tr valign="top">
    <td>
      <code>commutative_ring&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>commutative_addable&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>subtractable&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>commutative_multipliable&lt;&nbsp;T&nbsp;&gt;</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>commutative_ring&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>commutative_addable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>subtractable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>subtractable_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>commutative_multipliable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>ring&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>commutative_addable&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>subtractable&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>multipliable&lt;&nbsp;T&nbsp;&gt;</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>ring&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>commutative_addable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>subtractable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>subtractable_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>multipliable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td>
  </tr>

  <!-- field -->
  <tr valign="top">
    <td>
      <code>field&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>commutative_ring&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>dividable&lt;&nbsp;T&nbsp;&gt;</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>field&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>commutative_ring&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>dividable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>dividable_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td>
  </tr>

  <!-- ordered_commutative_ring -->
  <tr valign="top">
    <td>
      <code>ordered_commutative_ring&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>commutative_ring&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>totally_ordered&lt;&nbsp;T&nbsp;&gt;</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>ordered_commutative_ring&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>commutative_ring&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>totally_ordered&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td>
  </tr>

  <!-- ordered_ring -->
  <tr valign="top">
    <td>
      <code>ordered_ring&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>ring&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>totally_ordered&lt;&nbsp;T&nbsp;&gt;</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>ordered_ring&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>ring&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>totally_ordered&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td>
  </tr>

  <!-- ordered_field -->
  <tr valign="top">
    <td>
      <code>ordered_field&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>field&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>totally_ordered&lt;&nbsp;T&nbsp;&gt;</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>ordered_field&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>field&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>totally_ordered&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td>
  </tr>

  <!-- bitwise -->
  <tr valign="top">
    <td>
      <code>commutative_bitwise&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>commutative_andable&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>commutative_orable&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>commutative_xorable&lt;&nbsp;T&nbsp;&gt;</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>commutative_bitwise&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>commutative_andable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>commutative_orable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>commutative_xorable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>bitwise&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>andable&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>orable&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>xorable&lt;&nbsp;T&nbsp;&gt;</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>bitwise&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>andable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>orable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>xorable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>bitwise_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>andable_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>orable_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>xorable_left&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td>
  </tr>

  <!-- shiftable -->
  <tr valign="top">
    <td>
      <code>shiftable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>left_shiftable&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>right_shiftable&lt;&nbsp;T&nbsp;&gt;</code>
    </td>
  </tr><tr valign="top">
    <td>
      <code>shiftable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td><td>
      <code>left_shiftable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code><br>
      <code>right_shiftable&lt;&nbsp;T,&nbsp;U&nbsp;&gt;</code>
    </td>
  </tr>

  <!-- unit_steppable -->
  <tr valign="top">
    <td>
      <code>unit_steppable&lt;&nbsp;T&nbsp;&gt;</code>
    </td><td>
      <code>incrementable&lt;&nbsp;T&nbsp;&gt;</code><br>
      <code>decrementable&lt;&nbsp;T&nbsp;&gt;</code>
    </td>
  </tr>

</table>

Commutativity
-------------

For some templates, there are both commutative and non-commutative
versions available. If the class you are writing is commutative wrt an
operation, you should prefer the commutative template, i.e., the one which
has `commutative_` at the beginning.

It will be *more efficient* in some cases because it can avoid to create an
extra temporary for the result and it has *fewer requirements*.

The one-argument version of the commutative template provides the same
operators as the non-commutative one, but you can see from the result type
in which cases creating a temporary (returning `T`) can be avoided
(returning `T&&`).

For the two-argument version, `commutative_{OP}<&nbsp;T,&nbsp;U&nbsp;>` provides the operators
of both `{OP}<&nbsp;T,&nbsp;U&nbsp;>` and `{OP}_left<&nbsp;T,&nbsp;U&nbsp;>`, again the return type indicates
those cases where an extra temporary is avoided.

noexcept
--------

If your compiler does not support `noexcept`, the following might be a viable
work-around:

```c++
#include <utility> // make sure it's included before the following!
#define noexcept(...)
#include <df/operators.hpp>
#undef noexcept
```

With this little hack, **df.operators** can be used with GCC 4.4+.

Contact
-------

In case of any question or feedback, send email to <d.frey@gmx.de>.

License
-------

Copyright Daniel Frey 2013-2014.<br>
Distributed under the Boost Software License, Version 1.0.<br>
(See accompanying file `LICENSE_1_0.txt` or copy at <http://www.boost.org/LICENSE_1_0.txt>)

>Boost Software License - Version 1.0 - August 17th, 2003
>
>Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software is furnished to do so, all subject to the following:
>
>The copyright notices in the Software and this entire statement, including the above license grant, this restriction and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all derivative works of the Software, unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.
>
>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

The [Open Source Initiative](http://www.opensource.org/) certified the
[Boost Software License 1.0](http://www.opensource.org/licenses/bsl1.0.html) in early 2008.
